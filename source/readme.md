# source

## 一、架构

```shell
- main.cpp  # 编译器主函数

- frontend  # 前端基本内容
  - Shell  # 命令行输入
  - include  # 前端一切定义
  - Lexical  # 词法分析
  - Parsing  # 语法分析
  - Optimise  # 语义分析 & 优化
  - IRGen  # IR 生成
  
- back  # 后端基本内容

- 3rd-party  # 第三方库，比如命令行解析器

- demo.sysy  # 测试程序

- group-legacy  # 已废弃或待完善的代码
```

## 二、使用方式

自己利用 cmakelists 编译完毕后，在 build 文件夹中输入类似
```shell
hyouka ../demo.sysy --debug sym
```
的代码即可运行。

使用
```shell
hyouka --help
```
查看具体运行方式。


## 三、详细架构

详细内容请进入对应文件夹，查看 readme 或者源代码。

### （一）编译前端

#### 1，词法分析

- `source/front/Lexical`，词法 token
- 手写
- 负责者：tly, ss
- 错误类型
    - 词法错误：非法符号或名称
- 备注
    - 词法比较简单，没有什么值得备注的。不过本次采用了分割而非报错来处理一些连在一起的字符（比如1a会自动加空格分解为1和a；但是int2会理解会一个变量名毕竟这确实是合法的变量名），这和字符串的八进制转义的分割（遇到十进制数字分割而非报错）是异曲同工的。

#### 2，语法分析

- `source/front/Parsing`，AST 与符号表
- 手写
- 负责者：ss
- 错误类型
    - 语法错误：符号名称不符合语法规范
    - 符号错误：未定义的引用、重复定义
- 备注
    - 语法的整体框架非常清晰，但是在加了符号表以后显得很杂。
    - 尤其是符号表的上下传输，以及与 token、AST 属性这两者的同步，非常繁琐。
    - 不打算重构了，用注释标注了所有符号表出现的地方，可以便捷的 debug（仅仅是繁琐，不会出错）。个人打算找到一个非常优秀的架构方案再重构。

#### 3，语义分析 & 前端优化

- `source/front/Semantic`，AST 与符号表（更新版）
- 手写
- 负责者：ss
- 错误类型
    - 语义错误：隐式强制转换不合规范、% 使用浮点、（优化时）除0等。
- 优化内容
    - 常量计算
    - constexpr 计算（constexpr 指在编译阶段就能确定值的 const）
- 备注
    - 数组的优化还没写，防止炸。

#### 4，中间代码生成

- `source/front/IR`, IR
- 仿照 LLVM 的子集（修改版）手写
- 负责者：ss
- 无错误类型

### （二）编译后端

指令选择

指令调度

寄存器优化

### （三）静态库链接

...

### （四）转机器码

...